쓰레드
runnable이라는 인터페이스를 인플리멘츠를 한 클래스만 쓰레드가 받을수있음(new Horese가 runnable을 받아서 가능)
new Thread t1=new Thread(new Horse(매개변수));
new Thread t2=new Thread(new Horse(매개변수));
new Thread t3=new Thread(new Horse(매개변수));


객체명.start()로 쓰레드가 구동됨

쓰레드 특징:
t1.strart();
t2.strart();
t3.strart();
가 있다고 가정하면 전부 동시에 구동이 됨

프로세스:프로그램의 전체 (main을 포함)
쓰레드:프로그램의 일부(main을 포함하지 않음)
프로세스 내부에 쓰레드가 다수 분포하여 일을 처리하고있는 구조

공통점은 모두 cpu상에서 구동되고 있기에 이것은 모두 메모리에 올라가있다는 뜻이 되는것
=>둘다 객체에 해당함

실제 유사 사항 
은행
자본금 천억을 보유하고 있는 은행클래스를 만듦 

 thread를 상속 받는 거래처 클래스를 2개 만듦  
한개는 입금(100억)
한개는 출금 (100억)
만 작동하게 설계

둘다 각자 100회 돌리면 원금은 유지되어야 하는데 실제로 돌려보면 원금이 바뀌어있음.
=>쓰레드의 문제점

문제점이 일어나는 이유
은행에 입력되어있는 money의 값이 critical Section의 영역에 있기에
=>제어권을 순차적으로 주고 받는게 아닌 무작위로 랜덤으로 주고 받기에 은행에 입력되어있는 값에 오류가 생긴다.


critical Section영역: 모두가 접근이 가능한 영역 스레드간의 공유 영역

해결법
Crirical Section과 Synchronization(동기화)로 위와 같은 문제점을 잡아 줄 수 있다.

위를 접하기전에 이해할 개념
1.프로세스와 스레드 v
2.Multi-Tasking

Multi-Tasking=>하나의 일을 빨리 쳐리하고(완료하고) 다음 작업에 이행함

컴퓨터에서 얘기하는 멀티 태스킹의 개념이 이와 동일하다. 
컴퓨터의 사향(spack)과 상관관계가 있음
3.00GHZ=>1초에 30억개의 명령을 처리할 수 있다.  
즉, 짧은 시간내에 준나게 많은 명령들을 수행 할 수 있다.
(대충 하나의 클래스에서 실행하는 명령들 대강 100~300개라고한다)

자신에게 주어진 시간이 있으면 그 시간을 모두 사용하면 제어권이 다음 프로세스로 넘어가게 된다 .
그 주어진 시간이 너무 짧기에 동시에 실행되고 있다고 우리 눈엔 보이는 것인다. 

따라서 에러가 난 이유는 주어진 시간이 너무 짧아서 값을 저장도 하지 못한채 다음 작업(스레드)에게 제어권을 넘겨 주었기 때문이다.

3.Context Switching
제어권이 넘어갈때 발생하는 이슈들을 방어하기 위한 매커니즘
a*3하는 스레드 클래스와 a*2하는 스레드를 동시에 돌린다고 하였을때
곱하는 과정에서 제어권이 넘어가게 되어버리면 
a*6하는 값이 랜덤하게 나오게됨 

이를 방지하기 위해선 전문어로 "데이터의 무결성을 보장"해야한다.
=>
어떠한 계산 식을 입력 하였을때 항상 일관된 결과를 만들어 내야 하는것  

제어권이 넘어가기 직전에 메모리에 백업을 시킨다.
제어권이 자신에게 돌아오게 되면 메모리에 백업한 정보를 하드웨어 자원(레지스터)에 복원 시켜서 작업을 이행한다.

단, 메모리에 백업을 하였다가 정보를 호출 해 오게 되면 메모리의 처리 속도가 느리기 때문에 가급적이면 최소한적으로 사용하는것이 좋다.
=>자동적으로 제어가 된다고 한다 지금은 알 필요없다고 한다.

우리가 알아야 할 것은 lock을 걸어주는 방식 
lock이라는 메소드를 호출하여 Crirical Section의 정보가 해당되어 있는 공식을 감싸주어 계산이 끝날때까지 제어권을 안 넘기는 식으로 관리를 해준다.

try{
lock을 걸어줌 
식을 적어줌}

catch(){}
finally(){
lock을 풀어줌 }

join을 써주는 이유가 main클래스도 thread와 함께 스타트를 해버리기 때문에 threa에서 값이 나올떄까지 대기 하라고 join을 쓰는건가요?

join메소드는 대기하라는 함수인가요?





public void CalcurateSmallSquare() {
        tmp=0;
        for(int i=0; i<arraywidth.length; i++){
            tmp+= arraywidth[i]*Height;
        }
        System.out.println(tmp);



