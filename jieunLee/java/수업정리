1일차

<터미널에서 커밋>
- git add .
- git commit -m "커밋메시지"
- git push origin main

<파일 관련 명령어>
- touch 파일이름 //텍스트파일 생성

<인텔리제이 자동완성 키>
- psvm public static void main(String[] args) {}
- sout System.out.println();

<깃허브 협업>
- 원본에 Fork 하여 사본생성
- 사본에서 Full requests 하여 병합 요청
- 원본주인이 fetch upstream 하여 병합

2일차

데이터타입
- BigInteger num0; //무한대 정수
- int num1 = 5;
- float num2 = 3.3f; //double과 구분하기위해 뒤에 f를 붙임
- double num3 = 7.7; 

final //재활용이 안되는 박스
- 상수값을 지정
- 변수명은 전부대문자로 만든다.
- 문제에서 고정된 값이나 구하는 값에 사용
	ex)구구단의 시작과 끝, 스테이지 설정
	final int STAGE = 7;
	final int START = 1;
	final int END = 10;

static //전역변수

Math.random()
- 0부터 1미만의 난수를 발생
- (int)(Math.random()*(최대값-최소값+1)+최소값)
Math.pow(x, y) //x의 y승 구하기
Math.abs(rand) //절댓값 구하기



변수이름은 구분할 수 있도록 단어위주로 선언

전위연산자와 후위연산자
++i 해당 줄이 실행되기 이전에 덧셈이 완료됨
i++ 해당 줄이 실행된 이후에 덧셈이 완료됨

반복문 
증감이 필요한 경우 for문을 쓰자
무한루프는 for(;;){} 을 쓰자
break를 걸면 loop를 빠져나옴

지역변수: 중괄호가 끝날때까지 살아있는 변수

배열생성
데이터타입[] 변수이름 = new 메모리데이터타입[갯수];
	int[] arr1 = new int[10];
	BigInteger[] arr2 = new BigInteger[10];

Scanner: 사용자의 입력을 받음
import java.util.Scanner;
Scanner 변수이름 = new Scanner(System.in);
int num = scan.nextInt();
String str = scan.nextLine();
 

16진수표현
0xff //--> 10진법으로 계산하면 16^1*f + 16^0*f = 240 + 15 = 255
0xff //--> 2진법: 1111 1111 --> 빠르게 계산하면 2^8-1 = 255

if: 범주형 데이터
switch: 하나하나 세부 옵션
switch (num) {
	case 1:
		sout("num이 1이면 출력");
		break;
	case 2:
		sout("num이 2이면 출력");
		break;
	default:
		sout("나머지 경우 출력");
		break;
}

<Class>

SRP원칙: 하나의 클래스는 하나의 도매인만 다룬다. (특정 행동만 다루도록 해야함)
객체: 행동을 정의하는 주체
객체지향: 엔티티의 오염도를 낮추면서 모든 행동들을 각각의 클래스로 분리
함수형언어: 병렬처리에 특화

public class Person {
	public void setName () { //public 리턴데이터타입없음 메서드이름 (데이터타입 변수이름) --> 입력받은 내용이 소괄호로 옴
	this.name = name; //객체에는 this가 붙음, 그냥 name은 입력으로 받은 name
	}
	public String getName () { //public 리턴데이터타입String 메서드이름 () --> 입력받은게 없음
	return name; //입력받은게 없으니 name은 객체의name
	}
}

Person person = new Person(); //클래스를 객체화하겠다, 생성자 호출하겠다. --> 커스텀데이터타입 객체이름 = new 클래스명();
person.setName //person객체내부에 있는 정보에 접근

str.equlas("abc") //문자열비교


클래스를 객체화할때 반드시 생성자를 호출해야함

<생성자>
public class Person {
	public Person (int intNum, float floatNum) {
	}
	//이름은 클래스 이름과 동일하게한다
	//리턴 타입이 없다.
}

Person person = new Person(2, 3.1f); //클래스를 객체화하겠다, 생성자 호출하겠다.
//person.initName(); 와 같은 코드를 안써도됨




1/5 평가 
배열, Scanner, 클래스, 생성자, 함수 오버로딩(입력 개수 다르면 같은 이름으로 여러개 만들 수 있는거)
4번
-데이터타입과 갯수가 같으면 에러난다.
-리턴타입은 달라도 상관없다.


<추상화>
사용자가 기능을 몰라도 서비스를 사용할 수 있어야 한다.

<유틸리티 메소드> ????

<상속>
public class Person {
	private name;
	private age;
}
public class Student extends Person { 	//extends: Student가 Person을 상속받음
	private String major;
	public Student (String name, int age, String major) {
		super(name, age); 	//super: 부모클래스 호출하여 인자 전달
}

<인터페이스> 엔티티오염방지
public interface Comparable {
	int compareTo(Object other); 	//리턴타입, 이름(입력인자)만 있는 경우를 메서드의 프로토타입이라고 한다.
					//인터페이스는 프로토타입만 작성하고 기능은 implements가 해준다
}
public class InterfaceTest {
	psvm
	JavaStrcmp js = new JavaStrcmp(107.3);
}
public class JavaStrcmp implements Comparable { //implements: comparable 인터페이스를 javaStrcmp가 구현하겠다
	private double doubleNum;
	public JavaStrcmp (double doubleNum) {
		this.doubleNum = doubleNum;
	}
	//commend+n
}

<접근제어자>
public		//전체 공유
protected	//상속 공유
private		//개인

<ArrayList>					//배열은 크기가 고정되어있지만 arrayList는 사이즈가 동적인 배열이다.
ArrayList<데이터타입> 이름list = new ArrayList<>();	//데이터타입: int, String , (객체화된)클래스 등 모두 가능
list.add(인덱스, 요소);				//해당 인덱스에 요소를 넣으면 나머지는 뒤로 밀려남
list.size();
list.get(인덱스);

public enum 클래스명	//static final int 안적어도됨

<Vector>						//어레이리스트랑 비슷, 대신 사용해도 큰 문제는 없음
Vector<데이터타입String> 이름v = new Vector<>();	//기본사이즈 0인 벡터 생성
v.addElement(new String("값"));			//요소를 추가할때마다 사이즈 1 증가
String tmp = v.elementAt(인덱스1)			//추출

Vector<Object> v = new Vector<>();
v.addElement(new Character('A'));
v.addElement(new BigInteger("333"));
v.insertElementAt(new Float(3.14), 인덱스1);	//인덱스에 넣고 나머지는 뒤로 밀려남
v.setElementAt("안녕", 인덱스3);			//해당 인덱스 값 변경, object라서 데이터타입 달라도됨
v.remove(인덱스1)					//제거하고 나머지는 앞으로 당겨짐
(Character) v.elementAt(0);

<forEach문>
for (Test t: list) {				//Test타입의 t선언, 리스트의 정보가 하나씩 t에 들어감
	sout(t);
}

Set<String> s = new HashSet<>();
String[] duplicate = {"중복", "중복", "노중복"}
for (String dup: duplicate) {
	if(!s.add(dup)) {			//dup에 이미 있는 값이면 false리턴 -> !부정으로 true
		sout("중복된 단어: " + dup);

<Map>
Map<키Integer, 값Test> test = new Map<>();
test.put(키1, 값new Test());
test.remove(키2);
test.get(키3);
for (Map.Entry<Integer, Test> t: test.entrySet()) {
	Integer key = t.getKey();
	Test value = t.getValue();
	sout("키="+key+"값="+value)

List<Integer> list = new ArrayList<>();
for (int i=1; i<=10; i++) {
	list.add(i)
Collections.shuffle(list);
sout(list);

<Random>
Random 이름 = new Random();
int rand;
rand = 이름.nextInt(7777);			//0~7776까지 랜덤발생(최대7.776초)
rand = 이름.nextInt(7777)+10;		//10~7776

<Thread>					//분할시켜서 동시에 해결해주려고 사용
Thread t1 = new Thread(new Horse());	//new Thread(new 클래스()); -> 해당 클래스를 객체화하여 스레드화시킴
t1.start();				//.start()에 의해 implements가 구동됨
try {} catch {} finally {}		//try내 코드에 문제가 생기면 catch에서 알려준다. finally는 문제랑 상관없이 무조건 실행

Thread t1 = new Thread(new Horse());
Thread t2 = new Thread(new Horse());
Thread t3 = new Thread(new Horse());	
t1.start();				//t1, t2, t3는 거의 동시에 구동됨
t2.start();				
t3.start();

무결성 ?

- private
+ public

오늘까지의 출석부
훈련참여확인서
02-6952-0336
69520337
			

List는 인터페이스화 되어있음. 콜랙션(인터페이스화 되어있음)을 상속받고있음		
ArrayList는 클래그로 구성되어있음. 리스트를 implement하고있음

static = 동일한 값을 계속 사용할때 쓰면 되는걸까요?
변하지않고 이어나가야함
유지시켜줘야함
