public class WhyThreadMakesProblem {

    // Thread가 문제를 일으키는 이유는?
    /*
        앞선 상황에서 문제가 된 이유가 도대체 무엇일까?
        상황을 좀 더 간소화애서 정리를 해보자면 아래와 같은 상황임.
        두개의 스레드가 있고 이 녀석들이 함께 공유하는 자원 전역 변수 money가 이씅ㅁ.
        money가 전역변수인 이유는 main이 있는 DiscorruptBankSituationExample에서
        money가 있는 DiscorrputBank 객체를 static으로 고정시켰기 때문.
        그러므로 DiscorrputBank에 있는 money 도한 전역으로 활요할 수 있다.

                        money
                        10000
        ---------------------------------------
         Thread A                    Thread B
          + 1원                        -1원
       -----------------------------------------

        Thread A 가 money를 읽음 -> 10000
        입금을 하기전 Thread B 로 제어권이 넘어감, Thread B 가 money를 읽어도 -> 10000
        Thread B가 10000 -1
        Thread A가 10000 +1
        값이 서로 다르게 일어남.

        // 제어권이 넘어가기때문에 문제가 발생함.
        // 제어권을 안넘길 수는 없다.

        Critical Section은 특성 자원을 동시에 접근하는 상황이 발생할 수 있는 모든 영역에 붙이는 이름이다.
        Critical Section을  두 글자로 표현하자면 '변수' 이다.

        만약 이 money에 쓰레드가 하나만 접근하거나 혹은 접근을 할 수 없다면 Money는 Critical Section이 아니다.


        실행중에 제어권이 넘어 갈 수 있다.

        현재 이 문제를 해결하기 위해서는 몇 가지 개념이 정립되어야한다.
        1. 프로세스와 스레드
        2. Multi-Tasking(멀티 태스킹)

       이 개념은 과거 cpu가 1개 있더너 시절부터도 쭉 존재해왔던 개념.
        멀티 태스킹이란 용어는 스타크래프트에서도 자주 사용하는 용어
        실제로 게임 플ㄹ이어하는 개인 화면을 보면 정말로 동시에 여러가지를 하는가?/ 아니면 하나의 일을 굉장히 빨리 처리하고 다음 다음을 하는가?
        -> 빠른거.

        컴퓨터에서 이야기하는 멀티 태스킹의 개념도 완벽하게 이와 동일하다.
        현재 학원의 컴퓨터 스팩은 3.00GHz가 나옴.
        GHz라는건 3 * 10^9으로 1초에 10억본정도 진동
        이뜻은 컴퓨터가 1초에 30억개의 명령을 처리할 수 있다.

        야구 선수의 동체 시력은 0.3초 정도 감지 가능

        1초에 30억개니깐 0.3초면 ? 9억개

        보통 우리가 작성하는 프로그램 코드를 기계어로 변환하면 대략적으로 매서드 하나당 명령어 100개 ~ 300개 정도가 만들어짐.
        가끔 복작한 녀석들은 1000개 정도까지 나올 수 있다.

        0.0001초동안 하나의 프로그램을 다 돌리고도 시간이 남을까?
        시간이 남음
        너무 빨리 일을 처리할 수 있으니 컴퓨터는 우리에게 착시현상을 일으켜준다.
        작업 관리자에서 봤던 모든 프로세스에게 0.0001초씩 돌아요~ 하면 지금 200개가 있어도 0.02초면 모든 작업이 완료된다.

        실제로는 운영체제가 각각의 프로세스들에게 0.0001초보다 더 작은 시간을 주고 프로세스(프로그램)들을 구동시키게 된다.
        즉, 자신한테 주어진 시간이 있어서 그 시간을 모두 사용하면 제어권이 다음 프로세스에게 넘어가는 구조로 만들어져 있다.

        이렇게 빠르게 다음 다음 다음 하면서 진행되니
        사람이 느끼기엔 ??? 이 모든 것이 동시에 진행되는구나라는 착각에 빠지게 만든다.

        thread.sleep()을 하면 무조건 제어권이 다음사람한테 넘어간다.

        ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        활용할 수 있는시간 과 thread.sleep() 이 멈추는 시간 .. 여기서 뭐가 헷갈리는지는 모르겠지만.. 헷갈린다.
        아아ㅏ아ㅏ아 그 thread.sleep 어떻게 자신한테 돌아오는가?
        다음에 할게 있는데 그걸 어떻게 할까...?
        다음에 할걸 끝내고 돌아오는건가/ 아니면 우선순위가 따로 있는건가?
        ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★


        3. Context Switching(컨텍스트 스위칭) -> 운영체제가 처리함.

        컨텍스트 스위칭은 무엇이냐?
        제어권이 넘어갈때 발생하는 이슈들을 방어하기 위한 매커니즘.

        앞서 제어권이 넘어간다고 얘기했던 사항들은 아래 기계어를 전부 실행하지 못한 상태로
        다른 쓰레드나 프로세스로 제어권이 넘어가는 상황을 의미한다.


        어떤 경우엔 곱하기 2가 잘 되고(제어권이 안넘어가면 )
        어떤 경우에는 곱하기 6이 되고 (제이권이 넘어가면)

        이런 상황에서는 우리가 어떤 작업을 의도하고 코드화 할 수 없다.

        즉, 이런 상황이 발생하지 않도록 하는 걸 "데이터의 무결성"을 보장해야한다. // 컨텍스트 스위칭이 발생(데이터 무결성!)

        데이터 무결성을 보장하기 위해 실제 cpu가 사용하는 하드웨어 자원을 제어권이 넘어가기 직전에 메모리에 백업시킨다.
        그리고 제어권이 다시 자신에게 돌아오면 메모리에 백업한 정보를 하드웨어 자원(레지스터)에 복원시켜서 작업한다.
        // 백업과 보정을 추가

        결론 : Context Switching을 너무 자주하게 프로그램을 만들면 스레드를 사용하는 의미 자체가 없어져 버릴 수 있다.
              잘 사용해야한다.
              Context Switching은 돈이 들기 때문에


        ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        쓰레드는 Critical Section 을 제대로 확인해야한다.


*/
}
